\documentclass[11pt, oneside]{memoir}

\usepackage{fullpage}
\usepackage{xspace}
\usepackage{makeidx}
\usepackage{listings}
\usepackage{multicol}
\usepackage{graphicx}
\usepackage[colorlinks=true, linkcolor=blue]{hyperref}

\setlength{\parindent}{0pt}
\nonzeroparskip

% add padding to ctabular tables
\renewcommand{\arraystretch}{1.2}

\makeindex

%
% COMMANDS
%
\newcommand*{\cqueues}[0]{\texttt{cqueues}\xspace}
\newcommand*{\key}[1]{#1\index{#1}\xspace}
\newcommand*{\syscall}[1]{\texttt{#1}\xspace}
\newcommand*{\routine}[1]{\texttt{#1}\xspace}
\newcommand*{\fn}[1]{\texttt{#1}\xspace}
\newcommand*{\method}[1]{\texttt{#1}\xspace}
\newcommand*{\module}[1]{\texttt{#1}\xspace}
\newcommand*{\errno}[1]{\texttt{#1}\xspace}

%
% ENVIRONMENTS
%
\lstdefinelanguage{lua}{
morekeywords={break,goto,do,end,while,repeat,until,if,then,elseif,else,for,in,function,local,nil,false,true,and,or,not},
sensitive=true,
morestring=[b]"
}

\lstnewenvironment{code}[1]{
	\lstset{language=#1}
}{
}

\lstnewenvironment{example}[1]{
	\lstset{language=#1,numbers=left,numberstyle=\tiny,stepnumber=2,tabsize=4}
	\ttfamily\small
}{
}

\newcounter{toccols}
\setcounter{toccols}{2}
\newenvironment{Module}[1]{
	\subsection{\texttt{#1}}
	\addtocontents{toc}{
		\protect\begin{multicols}{\value{toccols}}
		%\renewcommand*{\cftsubsubsectiondotsep}{\cftnodots}%
	}
}{
	\addtocontents{toc}{\protect\end{multicols}}
}


\lstdefinelanguage{lua}{morekeywords={break,goto,do,end,while,repeat,until,if,then,elseif,else,for,in,function,local,nil,false,true,and,or,not},sensitive=true,morestring=[b]"}


\begin{document}

%\pagestyle{empty}

\title{
\HUGE\sffamily The \cqueues User Guide \\

%\vspace*{20pt}
%\hrule

\vspace*{10pt}
\LARGE for composing \\
\vspace*{10pt}

\HUGE Socket, Signal, Thread, \& File Change Messaging \\

%\vspace*{20pt}
%\hrule

\vspace*{10pt}
\LARGE on \\
\vspace*{10pt}

\HUGE Linux, OS X, Solaris, \\ FreeBSD, NetBSD, \& OpenBSD

\vspace*{10pt}
\LARGE with \\
\vspace*{10pt}

% ps2pdf -dEPSCrop lua.ps
{\includegraphics[scale=0.10]{art/lua.pdf}}

\vspace*{30pt}
\hrule
}

\date{\today}
\author{William Ahern}
%\setlength{\droptitle}{85pt}
\maketitle
\thispagestyle{empty}
\clearpage

\maxtocdepth{subsubsection}
\setsecnumdepth{subsection}
\setcounter{page}{1}
\pagenumbering{roman}
\tableofcontents

\clearpage

\setcounter{page}{1}
\pagenumbering{arabic}

\chapterstyle{section}

\chapter{Dependencies}

\section{Operating Systems}

\cqueues heavily relies on a modern POSIX environment. But the fundamental premise is to build on the new but non-standard polling facilities provided by contemporary Unix environments. Specifically, BSD \syscall{kqueue}, Linux \syscall{epoll}, and Solaris Event Ports.

\cqueues should work on recent versions of Linux, OS X, Solaris, NetBSD, FreeBSD, OpenBSD, and derivatives. The only other possible candidate is AIX, if and when support for AIX's \syscall{pollset} interface is added to the embedded ``kpoll'' library.

\subsection{$\lnot$ Microsoft Windows}

Microsoft Windows support is basically out of the question, for far too many reasons to put here. Aside from the more technical reasons, Windows I/O and networking programming interfaces have a fundamentally different character than on Unix. Unix historically relies on readiness polling, while Windows uses event completion callbacks. There are strengths and weaknesses to each approach. Trying to paper over the chasm between the two approaches invariably results in a framework with the strengths of neither and the weaknesses of both. The purpose of \cqueues is to leverage the strengths of polling as well as address the weaknesses.

\section{Libraries}

\subsection{Lua 5.2, LuaJIT}
\cqueues principally targets Lua 5.2. It's not fully portable to Lua 5.1 because \cqueues relies on ephemeron tables to prevent coroutine/controller reference cycles, and because Lua 5.1 does not support yielding from metamethods and iterators. LuaJIT removes the latter of these handicaps, and so \cqueues targets LuaJIT secondarily. In lieu of ephemeron tables, application code must be sure not to hold a reference to a parent controller in an upvalue of the coroutine. Instead, use \fn{cqueues.running}.

\subsection{OpenSSL}
The \cqueues \module{socket} module provides seamless SSL/TLS support using OpenSSL, and comprehensive bindings for certificate and key management are provided in the extension \module{openssl} module.

\subsection{pthreads}

\cqueues provides an optional threading module, using POSIX threads.\footnote{Building without threading enabled is not well tested.} Internally it consistently uses thread-safe routines when built with either the \_REENTRANT or \_THREAD\_SAFE feature macros, such as \syscall{pthread\_sigmask} instead of \syscall{sigprocmask}. Thread support is enabled by default.

\paragraph{Linking}
Note that on some systems, such as NetBSD and FreeBSD, the loading application must be linked against pthreads (using -lpthread or -pthread). It is not enough for the \cqueues module to pull in the dependency at load time. In particular, if using the stock Lua interpreter, it must have been linked against pthreads at build time. Add the appropriate linker flag to MYLIBS in lua-5.2.x/src/Makefile.

\paragraph{OpenBSD}
OpenBSD 5.1 threading is completely \emph{fubar}, especially with regard to signals, because of OpenBSD's transition to kernel threading. If using OpenBSD, be sure to compile \emph{without} the thread-safe macros predefined, especially if using \module{cqueues.signal}.

\section{Compilers}

The source code is mostly ISO C99 compliant, and even more so with regards to ISO C11. Regardless, it aims to build cleanly with the native compiler for each targeted platform. It currently builds with recent versions of GCC, clang, and SunPro.

GCC and especially clang may emit copious warnings about initializers and unused parameters. These warnings, particularly the former, are stupid---for lack of a better term. The Makefile uses -Wno-override-init (GCC), -Wno-initializer-overrides (clang), and -Wno-unused to quiet these.

SunPro has a broken diagnostic pass confused by macro-generated function calls.\footnote{\texttt{e.g.\ "lib/fifo.h", line 348:\ warning:\ argument mismatch}.} Likewise, the code flow analyzer in older versions of GCC---especially on the BSDs---emits erroneous uninitialized use warnings. Newer versions also occasionally get this wrong, but not nearly as often, and so the code is refactored to reduce noise so that legitimate warnings are not suppressed.

For other warnings or errors, patches are welcome.

\section{Makefile}

The Makefile requires GNU Make, usually installed as gmake on platforms other than Linux or OS X.

The Makefile expects Lua headers to exist in \$(includedir)/lua/5.2. This is unfortunately not the default install location for Lua headers, although it quite obviously ought to be. To source the usual location, try something like

\begin{code}{sh}
make prefix=/opt/lua52 luainclude=/opt/lua52/include
\end{code}

Other important Make variables to consider include luapath, luacpath, and LUAC. They default to \$(prefix)/share/lua/5.2, \$(prefix)/lib/lua/5.2, and \$(prefix)/bin/luac, respectively. The install target can build the library from scratch, so there's no need to `make depends' or `make all'. `make help' will emit additional usage information.

%\begin{code}{sh}
%make prefix=/opt/luajit \
%     lua52include=/opt/luajit/include/luajit-2.0 \
%     lua52cpath=/opt/luajit/lib/lua/5.1 \
%     lua52path=/opt/luajit/share/lua/5.1 \
%     LUAC=/usr/bin/true
%\end{code}

\key{M4} and \key{awk} are required to generate errno.c, which also relies on mk/errno.ls and mk/macros.ls to enumerate the system error macro names.

\chapter{Usage}

\section{Conventions}


\subsection{Polling}

\cqueues works through a simple protocol. When a coroutine yields to its parent \cqueues controller, it can pass one or more objects. These objects are introspected for three methods: \method{:pollfd}, \method{:events}, and \method{:timeout}. These methods generate the parameters for installing descriptor and timeout events. When one of these events fires, \cqueues will resume the coroutine, passing the relevant objects which were interested in the triggered event. It's analogous to calling \syscall{poll}, and in fact the routine \routine{cqueues.poll} is provided as a wrapper for \routine{coroutine.yield}.\footnote{In the future this wrapper may be able to detect if the current coroutine was resumed by a controller, and if not chain yield calls until a controller is reached.}

\subsubsection[\method{object:pollfd}]{\method{:pollfd()}} The \method{:pollfd} method should return a descriptor integer or nil. This descriptor must remain in existence until the owner object is garbage collected, \routine{cqueues.cancel} is used, the coroutine executes one additional yield/resume cycle (so the old descriptor is expired from the descriptor queue), or until after the coroutine exits. If the descriptor is closed prematurely, the kernel will remove it from the internal descriptor queue, bringing it out of sync with the controller, and probably causing \method{cqueues:step} to return EBADF or ENOENT errors.

\subsubsection[\method{object:events}]{\method{:events()}} The \method{:events} method should return a string or nil. \cqueues searches the string for the flags `r' and `w', which describe the events to associate with the descriptor---respectively, POLLIN and POLLOUT.

\subsubsection[\method{object:timeout}]{\method{:timeout()}} The \method{:timeout} should return a number or nil. This schedules an independent timeout event. To effect a simple one second timeout, you can do

\begin{code}{perl}
        cqueues.poll({ timeout = function() return 1.0 end })
\end{code}

which is equivalent to

\begin{code}{perl}
	coroutine.yield({ timeout = function() return 1.0 end })
\end{code}

but not quite as simple as the shortcut

\begin{code}{perl}
	cqueues.poll(1.0)
\end{code}

Instantiated \cqueues objects implement all three methods.\footnote{\method{:pollfd} returns the internal \syscall{kqueue}, \syscall{epoll}, or Ports descriptor; \method{:events} returns ``r''; and \method{:timeout} returns the time to the next internal timeout event.} In particular, this means that you can stack \cqueues, or poll on a \cqueues object using some other event loop library. Each \cqueues object is entirely self-contained, without any global state.

\subsection{$\lnot$ Globals}

Like the core controller module, other \cqueues modules adhere to a \emph{no global side effects} discipline. In particular, this means
\begin{itemize}
\item no global process variables;
\item no signal handling gimmicks---like the pipe trick---which could conflict with other components of your application\footnote{The \module{cqueues.thread} module ensures threads are started with a filled signal mask.};
\item consistent use of thread-safe function variants; and
\item consistent use of O\_CLOEXEC and similar flags to eliminate or reduce \syscall{fork} $+$ \syscall{exec} races in threaded applications.
\end{itemize}

\subsection{Errors}

The usual behavior is for errors to be returned directly. But see \routine{socket.onerror}. If a routine is specified to return an object or string, nil is returned; if a boolean, false is returned. In both cases, these  are usually followed by a numeric error code. Thus, if a routine is specified to return two values on success, then on error three values are returned, the first two nil or false, and the third an error code.

\cqueues is a relatively low-level component library. In almost all cases errors will be system errors, returned as numeric error codes for easy and efficient comparison. For example, attempting to create a UNIX domain socket with \routine{socket.listen} in a directory without sufficient permissions might return `nil, \errno{EACCES}'.

\subsubsection{\texttt{EAGAIN}}

\cqueues modules are implemented in both C and Lua. The C routines never yield, and always return recoverable errors directly. Most C routines are wrapped---and methods interposed---with Lua functions. These Lua functions usually poll when \errno{EAGAIN} is encountered and retry the C routine on resumption. Few methods will return \errno{EAGAIN} directly.

\subsubsection{\texttt{ETIMEDOUT}}

This error value is usually seen when a timeout is specified by the caller of a logically synchronous method. The method will normally yield and poll if the operation cannot be completed immediately, but if the timeout expires then it will return a failure with \errno{ETIMEDOUT}.

\subsubsection{\texttt{EPIPE}}

In Unix \errno{EPIPE} is only encountered when attempting to write to a closed pipe or socket. In \cqueues \errno{EPIPE} is used to signal both EOF and a closed output stream.\footnote{In some situations, such as with SSL/TLS, a read attempt might require a write, anyhow. Expanding the scope of EPIPE simplifies the logic required to handle various I/O failures.} The low-level I/O method \method{socket:recv}, for example, returns \errno{EPIPE} on EOF. In other cases, as with \method{socket:read}, EOF is not an error condition.

\subsubsection{\texttt{EBADF}}

This error commonly occurs in asynchronous applications, which are especially prone to bugs related to their complex state management. With Lua code using the \cqueues APIs, \errno{EBADF} should never be encountered. When it does occur, it's a sure sign of a bug somewhere in the parent application or an extension module and---hopefully---not \cqueues.

\section{Modules}

\begin{Module}{\cqueues}

\subsubsection{\routine{cqueues.VENDOR}}
String describing the vendor, e.g.\ william@25thandClement.com. If you fork this project please change this string so I don't receive unwarranted scorn or praise.

\subsubsection{\routine{cqueues.VERSION}}
Number describing the running version, formatted as YYYYMMDD. Official releases are tagged in the git repo as rel-YYYYMMDD.

\subsubsection{\routine{cqueues.COMMIT}}
Git commit hash string of HEAD.

\subsubsection[\routine{cqueues.interpose}]{\routine{cqueues.interpose(name, function)}}
Add or interpose a \cqueues controller class method. Returns the previous method, if any.

\subsubsection[\routine{cqueues.monotime}]{\routine{cqueues.monotime()}}
Return the system's monotonic clock time, usually clock\_gettime(CLOCK\_MONOTONIC).

\subsubsection[\routine{cqueues.cancel}]{\routine{cqueues.cancel(fd)}}
Cancels the specified descriptor for all controllers. This ensures safe early closure of descriptors. However, the complexity is approximately M 2 log N, where M is the number of controllers, and N the number of descriptors per controller (presuming equal distribution). For most purposes this is entirely inconsequential. By contrast, however, implicit cancellation through GC or yield/resume cycling is O(1).

Any coroutine polling on the canceled descriptor is placed on its controller's pending queue.

\subsubsection[\routine{cqueues.poll}]{\routine{cqueues.poll($\ldots$)}}
Takes a series of objects obeying the polling protocol and yields control to the parent \cqueues controller. On an event resumes the coroutine, passing the objects which triggered resumption. A number value is interpreted as a timeout.

\subsubsection[\routine{cqueues.sleep}]{\routine{cqueues.sleep(number)}}

Yields to the parent \cqueues controller and schedules a wakeup for `number' seconds in the future.

\subsubsection[\routine{cqueues.running}]{\routine{cqueues.running()}}

Returns two values: the immediate controller currently executing, if any, or nil; and a boolean---true if the caller's coroutine is the same coroutine resumed by the controller.

\subsubsection[\routine{cqueues.new}]{\routine{cqueues.new()}}
Create a new cqueues object.

\subsubsection[\routine{cqueues:attach}]{\routine{cqueue:attach(coroutine)}}
Attach and manage the specified coroutine.

\subsubsection[\routine{cqueues:wrap}]{\routine{cqueue:wrap(function)}}
        Execute function inside a new coroutine managed by the controller.

\subsubsection[\routine{cqueues:step}]{\routine{cqueue:step([timeout])}}
Step once through the event queue. If no timeout is provided, \emph{it suspends the process indefinitely} until a descriptor event or timeout fires.

Returns true or false. If false---i.e. a coroutine exited abnormally---then a second return value holds the error message. :step can be called again after errors.

For a controller running from the main Lua thread and which may suspend the process, the convention is to loop like

\begin{code}{lua}
while not cq:empty() do
	local okay, why = cq:step()

	if not okay then
		-- handle error described by `why'
	end
end
\end{code}

For a controller in a coroutine managed by another controller, something like this might be more appropriate

\begin{code}{lua}
while not cq:empty() do
	cqueues.poll(cq)

	local okay, why = cq:step(0.0)

	if not okay then
		--- handle error
	end
end
\end{code}

A controller is a pollable object, and the descriptor returned by the :pollfd method can be used with third-party event libraries, whether written in Lua, C, or some other language. Don't forget to also schedule a timeout using the value from :timeout.

%[However, at the moment the controller cannot recover from synchronization errors with the kernel queue. In the future, internal, unrecoverable errors should be thrown and only coroutine errors returned directly.]

\subsubsection[\routine{cqueues:empty}]{\routine{cqueue:empty()}}
Returns true if there are no more descriptor or timeout events queued, false otherwise.

\subsubsection[\routine{cqueues:count}]{\routine{cqueue:count()}}
Returns a count of managed coroutines.

\subsubsection[\routine{cqueues:cancel}]{\routine{cqueue:cancel(fd)}}
Cancel the specified descriptor for that controller. See cqueues.cancel.

\subsubsection[\routine{cqueues:pause}]{\routine{cqueue:pause(signal [, signal $\ldots$ ])}}
A wrapper around \syscall{pselect} which \emph{suspends execution of the process} until the controller polls ready or a signal is delivered. This interface is provided as a very basic least common denominator for simple slave process controller loops and similar scenarios, where immediate response to signal delivery is required on platforms like Solaris without a proper signal polling primitive. (\routine{signal.listen} on Solaris merely periodically queries the pending set.)

Much better alternatives are possible for Solaris, but require global process state or an LWP thread helper.

\end{Module}

\begin{Module}{cqueues.socket}

\subsubsection[\fn{socket[]}]{\fn{socket[]}}

A table mapping socket related system identifier names to number codes, including AF\_UNSPEC, AF\_INET, AF\_INET6, AF\_UNIX, SOCK\_STREAM, and SOCK\_DGRAM.

\subsubsection[\fn{socket.interpose}]{\fn{socket.interpose(name, function)}}
Add or interpose a socket class method. Returns the previous method, if any.

\subsubsection[\fn{socket.connect}]{\fn{socket.connect(host, port [, mode])}}
Return a new socket immediately ready for reading or writing. DNS lookup and TCP connection handling are handled transparently.

`mode' is a string containing one or more of the following flags

\begin{ctabular}{c | p{6in}}
flag & description \\\hline
t & text mode; input and output undergo LF/CRLF translation \\
b & binary mode; no LF/CRLF translation \\
n & no output buffering \\
l & line buffered output \\ 
f & fully buffered output \\
\end{ctabular}
The default mode is ``tl''---text translation and line buffering. This makes sockets work intuitively with the most common protocols on the Internet, like SMTP and HTTP, which require CRLF and use line delimited framing.

\subsubsection[\fn{socket.connect}]{\fn{socket.connect\{ $\ldots$ \}}}
Like \fn{socket.connect}, but takes a table of options:

\begin{ctabular}{r | c | p{4.5in}}
field & type:default & description\\\hline
.host & string:nil & IP address or host domain name \\

.port & string:nil & host port \\

.path & string:nil & UNIX domain socket path \\

.family & number & protocol family---AF\_INET (default), AF\_INET6, AF\_UNIX (default if .path specified)\\

.type & number & protocol type---SOCK\_STREAM (default) or SOCK\_DGRAM\\

.mode & string:nil & fchmod or chmod socket after creating UNIX domain socket
%NOTE: There's a race between bind and the following chmod. fchmod is attempted before the bind, however it fails on BSD derivatives. Not all platforms obey UNIX domain socket permissions (e.g. Solaris). Check peer credentials, instead, to be portable.
\\

.mask & string:nil & set and restore umask when binding UNIX domain sockets %NOTE: Not all platforms obey UNIX domain socket permissions. Check peer credentials, instead, to be portable.
\\

.unlink & boolean:false & unlink socket path before binding \\

.reuseaddr & boolean:true & SO\_REUSEADDDR socket option \\

.nodelay & boolean:false & TCP\_NODELAY IP option \\

.nopush & boolean:false & TCP\_NOPUSH, TCP\_CORK, or equivalent IP option \\

.nonblock & boolean:true & O\_NONBLOCK descriptor flag \\

.cloexec & boolean:true & O\_CLOEXEC descriptor flag \\

.nosigpipe & boolean:true & O\_NOSIGPIPE, SO\_NOSIGPIPE, MSG\_NOSIGNAL, or equivalent descriptor flag \\

.verify & boolean:false & require SSL certificate verification \\

.time & boolean:true & track elapsed time for statistics \\
\end{ctabular}

\subsubsection[\fn{socket.listen}]{\fn{socket.listen(host, port)}}
	Return a new socket immediately ready for accepting connections.

\subsubsection[\fn{socket.listen}]{\fn{socket.listen\{ $\ldots$ \}}}
	Like \fn{socket.listen}. See also \fn{socket.connect\{\}}.

\subsubsection[\fn{socket.pair}]{\fn{socket.pair([type])}}
Returns two bound sockets. Type should be the system type number, e.g. \fn{socket.SOCK\_STREAM} or \fn{socket.SOCK\_DGRAM}.

\subsubsection[\fn{socket.setvbuf}]{\fn{socket.setvbuf(mode [, size])}}
	Set the default output buffering. See \fn{socket:setvbuf}.

\subsubsection[\fn{socket.setmode}]{\fn{socket.setmode([input], [output])}}
	Set the default I/O mode. See \fn{socket:setmode}.

\subsubsection[\fn{socket.onerror}]{\fn{socket.onerror([function])}}
	Set the default error handler. See \fn{socket:onerror}.

%\subsubsection[\fn{socket:connect}]{\fn{socket:connect()}}
%	Wait for connection establishment to succeed. [UNFINISHED]

%\subsubsection[\fn{socket:listen}]{\fn{socket:listen()}}
%	Wait for socket binding to complete, which may have been delayed if
%	the specified host required DNS resolution. [UNFINISHED]

\subsubsection[\fn{socket:accept}]{\fn{socket:accept([timeout])}}
Wait for and return an incoming client socket on a listening object.

\subsubsection[\fn{socket:clients}]{\fn{socket:clients([timeout])}}
Iterator over \method{socket:accept}: \texttt{for con in srv:clients() do ... end}.

%\subsection[\fn{socket:certify}]{\fn{socket:certify(certificate)}}
%	Associate a certificate for subsequent :starttls operation.
%	[UNFINISHED]

\subsubsection[\fn{socket:starttls}]{\fn{socket:starttls([context][, timeout])}}
Place socket into TLS mode, optionally using the \module{openssl.ssl.context} object as the configuration prototype. If no timeout specified,  returns immediately. Otherwise, retries and polls for up to `timeout' seconds for completion. Returns true on success, false and an error code on failure.

\subsubsection[\fn{socket:checktls}]{\fn{socket:checktls()}}

If in TLS mode, returns an \module{openssl.ssl} object, otherwise nil. If the openssl module cannot be loaded, returns nil and an error string.

\subsubsection[\fn{socket:setvbuf}]{\fn{socket:setvbuf(mode [, size])}}
Same as Lua \fn{file:setvbuf}. Analogous to ``n'', ``l'', and ``f'' mode flags.

\subsubsection[\fn{socket:setmode}]{\fn{socket:setmode([input], [output])}}
See \fn{socket.connect} for mode flags. One or both modes can be nil, in which case the mode is left unchanged.

Returns the previous input and output modes as fixed-sized strings. At present the first character is one of ``t'' or ``b'', and the second character one of ``n'', ``l'', ``f'', or ``-'' (for in the input mode).

\subsubsection[\fn{socket:onerror}]{\fn{socket:onerror([function])}}
Set the error handler. The error handler is passed the tuple socket-object, method-string, error-number, and is expected to either throw an error or return an error code---to be returned to the caller as part of the documented return interface.

The default error handler returns \errno{EPIPE} and \errno{ETIMEDOUT} directly, and throws everything else. \errno{EAGAIN} is handled internally for logically synchronous calls.

Returns the previous error handler, if any.

\subsubsection[\fn{socket:read}]{\fn{socket:read(...)}}
	Similar to Lua's \fn{file:read}, with additional formats.

\begin{tabular}{c | l}
format & description\\\hline
{*n} & unsupported \\
{*a} & unsupported \\
{*l} & read the next line, trimming the EOL marker \\
{*L} & read the next line, keeping the EOL marker \\
number & read `number' bytes or until EOF \\
{*h} & read and unfold MIME compliant header \\
{*H} & read MIME compliant header, keeping EOL markers \\
-number & read 1 to `number' bytes, immediately returning if possible \\
\end{tabular}

\subsubsection[\fn{socket:write}]{\fn{socket:write(...)}}
	Same as Lua \fn{file:write}.

\subsubsection[\fn{socket:flush}]{\fn{socket:flush([mode])}}
Flushes output buffer. Mode is one of the ``nlf'' flags described in \method{socket.connect}. A nil mode implies ``n'', i.e.\ no buffering and  effecting a full flush. An empty string mode resolves to the configured output buffering mode.

\subsubsection[\fn{socket:fill}]{\fn{socket:fill(size[, timeout])}}
Fills the input buffer with `size' bytes. Returns true on success, false and an error code on failure.

\subsubsection[{\fn{socket:unget}}]{\fn{socket:unget(string)}}
Writes `string' to the head of the socket input buffer.

\subsubsection[{\fn{socket:pending}}]{\fn{socket:pending()}}
Returns two numbers---the counts of buffered bytes in the input and output streams. This does not include the bytes in the kernel's buffer.

\subsubsection[\fn{socket:uncork}]{\fn{socket:uncork()}}
Disables TCP\_NOPUSH, TCP\_CORK, or equivalent socket option.

\subsubsection[\fn{socket:recv}]{\fn{socket:recv(format [, mode])}}
Similar to \method{socket:read}, except takes only a single format and returns immediately without polling. On success returns the string or number. On failure returns nil and a numeric error code--usually EAGAIN or EPIPE. Does not use error handler.

`mode' is as described in \fn{socket.connect}, and defaults to the configured input mode.

\subsubsection[\fn{socket:send}]{\fn{socket:send(string, i, j [, mode])}}
Write out the slice `string'[i,j]. Similar to passing \fn{string:sub(i, j)}, but without instantiating a new string object. Immediately returns two values: count of bytes written (0 to j-i+1), and numerical error code, if any (usually EAGAIN or EPIPE).

\subsubsection[\fn{socket:recvfd}]{\fn{socket:recvfd([prepbufsiz])}}
Receive an ancillary socket message with accompanying descriptor. `prepbufsiz' specifies the maximum message size to expect.

This routine bypasses I/O buffering.

Returns message-string, socket-object on success; nil, nil, error-integer on failure. On success socket-object may still be nil. Message truncation is treated as an error condition.

\subsubsection[\fn{socket:sendfd}]{\fn{socket:sendfd(msg, socket)}}
Send an ancillary socket message with accompanying descriptor. `msg' should be a non-zero-length string, which some platforms require. `socket' should be a Lua file handle, \cqueues socket, integer descriptor, or nil.

This routine bypasses I/O buffering.

Returns true on success; false and an error code on failure.

\subsubsection[\fn{socket:shutdown}]{\fn{socket:shutdown(how)}}
Simple binding to \syscall{shutdown(2)}. `how' is a string containing one or both of the flags ``r'' or ``w''.

\begin{tabular}{c | l}
flag & description \\\hline
r & analagous to \syscall{shutdown(SHUT\_RD)} \\
w & analagous to \syscall{shutdown(SHUT\_WR)} \\
\end{tabular}

\subsubsection[\fn{socket:eof}]{\fn{socket:eof()}}
Returns two boolean values representing whether EOF has been received on the input channel, and whether the output channel has signaled closure (e.g. \errno{EPIPE}).

\subsubsection[\fn{socket:peername}]{\fn{socket:peername()}}
Returns one, two, or three values. On success, returns three values for AF\_INET and AF\_INET6 sockets---the address family number, IP address string, and IP port. For AF\_UNIX sockets, returns the address family and file path. If the socket is not yet connected, returns the address family AF\_UNSPEC, usually numeric 0.

On failure returns nil and a numeric error code.

\subsubsection[\fn{socket:localname}]{\fn{socket:localname()}}

Identical to \fn{socket:peer name}, but returns the local address of the socket.

\subsubsection[\fn{socket:stat}]{\fn{socket:stat()}}

Returns a table containing two subtables, `sent' and `rcvd', which each have three fields---.count for the number of bytes sent or received, a boolean .eof  signaling whether input or output has been shutdown, and .time logging the last send or receive operation.

\subsubsection[\fn{socket:close}]{\fn{socket:close()}}
Explicitly and immediately close all internal descriptors. This routine ensures all descriptors are properly cancelled.

\end{Module}

\begin{Module}{cqueues.errno}

\subsubsection[\fn{errno[]}]{\fn{errno[]}}
A table mapping all system error string macros to numerical error codes, and all numerical error codes to system error string macros. Thus, \texttt{errno.EAGAIN} evaluates to a numeric error code, and \texttt{errno[errno.EAGAIN]} evaluates to the string ``EAGAIN''.

\subsubsection[\fn{errno.strerror}]{\fn{errno.strerror(code)}}
Returns string returned by strerror(3).
%[FUTURE: Will also handle embedded socket.c and dns.c library error codes.]

\end{Module}

\begin{Module}{cqueues.signal}

\subsubsection{\fn{signal[]}}
A table mapping signal string macros to numerical signal codes.
In all likelihood, \texttt{signal.SIGKILL} evaluates to the number 9.

\subsubsection[\fn{signal.strsignal}]{\fn{signal.strsignal(code)}}
Returns string returned by strsignal(3).

\subsubsection[\fn{signal.ignore}]{\fn{signal.ignore(signal [, signal $\ldots $ ])}}
Set the signal handler to SIG\_IGN for the specified signals.

\subsubsection[\fn{signal.default}]{\fn{signal.default(signal [, signal $\ldots$ ])}}
Set the signal handler to SIG\_DFL for the specified signals.

\subsubsection[\fn{signal.discard}]{\fn{signal.discard(signal [, signal $\ldots$ ])}}
Set the signal handler to a builtin ``noop'' handler for the specified signals. Use this is you want signals to interrupt syscalls.

\subsubsection[\fn{signal.block}]{\fn{signal.block(signal [, signal $\ldots$ ])}}
Block the specified signals.

\subsubsection[\fn{signal.unblock}]{\fn{signal.unblock(signal [, signal $\ldots$ ])}}
Unblock the specified signals.

\subsubsection[\fn{signal.raise}]{\fn{signal.raise(signal [, signal $\ldots$ ])}}
raise(3) the specified signals.

\subsubsection[\fn{signal.interpose}]{\fn{signal.interpose(name, function)}}
Add or interpose a signal listener class method. Returns the previous method, if any.

\subsubsection[\fn{signal.listen}]{\fn{signal.listen(signal [, signal $\ldots$ ])}}
Returns a signal listener object for the specified signals. Semantics differ between platforms:

\paragraph{kqueue}
BSD \syscall{kqueue} provides the most intuitive behavior. All listeners will detect a signal sent to the process irrespective of whether the signal is ignored, blocked, or delivered. However, EVFILT\_SIGNAL is edge-triggered, which means no notification of delivery of a pending signal upon being unblocked.

\paragraph{signalfd}
Linux \syscall{signalfd} will not detect ignored or delivered signals, and only one signalfd object will poll ready per signal.

\paragraph{sigtimedwait}
Solaris provides no signal polling kernel primitive. Instead, the pending set is periodically queried using \syscall{sigtimedwait}. See \method{signal:settimeout}. Like Linux, only one listener can notify per interrupt.

To be portable the application must block the relevant signals. See \fn{signal.block}. Otherwise, neither Linux nor Solaris will be able to detect the interrupt. Any signal should be assigned to one listener only, although any listener may query multiple signals.

Alternatively, applications may start a dedicated thread to field incoming signals, and send notifications over a socket. In the future this may be provided as an optional listener implementation.

See also \routine{cqueue:pause} for another, if crude, alternative.

\subsubsection[\fn{signal:wait}]{\fn{signal:wait([timeout])}}
Polls for the signal set passed to the constructor. Returns the signal number, or nil on timeout.

\subsubsection[\fn{signal:settimeout}]{\fn{signal:settimeout(timeout)}}
Set the polling interval for implementations such as Solaris which lack a signal polling kernel primitive. On such systems signal:wait merely queries the pending set every `timeout' seconds.

\end{Module}

\begin{Module}{cqueues.thread}

\subsubsection[\fn{thread.self}]{\fn{thread.self()}}
Returns the LWP thread object for the running Lua instances. Threads not started via thread.start return nil.

\subsubsection[\fn{thread.start}]{\fn{thread.start(function [, string [, string $\ldots$ ]])}}
Generates a socket pair, starts a POSIX LWP thread, initializes a new Lua VM instance, preloads the \cqueues library, and loads and executes the specified function from the new LWP thread and Lua instance. The function receives as the first parameter one end of the socket pair---instantiated as a \module{cqueues.socket} object---followed by the string parameters passed to thread.start.

The new LWP thread starts with all signals blocked.

Returns a thread object and a socket object---the other end of the socket pair. The thread object is pollable, and readiness signals that the LWP thread has exited, or is imminently about to exit.

On error returns two nils and an error code.

\subsubsection[\fn{thread:join}]{\fn{thread.join([timeout])}}
Wait for the thread to terminate. Calling the equivalent of thread.self():join() is disallowed.

Returns a boolean and error value. If false, error value is an error code describing a local error, usually \errno{EAGAIN} or \errno{ETIMEDOUT}. If true, error value is 1) an error code describing a system error which the thread encountered, 2) an error message string returned by the new Lua instance, or 3) nil if completed successfully.

\end{Module}

\begin{Module}{cqueues.notify}

\subsubsection[\fn{notify[]}]{\fn{notify[]}}
A table mapping bitwise flags to names, and vice-versa.

\begin{tabular}{c | l}

name & description \\\hline
CREATE & file creation event \\
ATTRIB & metadata change event \\
MODIFY & modification to file contents or directory entries \\ 
REVOKE & permission revoked \\
DELETE & file deletion event \\
ALL    & bitwise-or of CREATE, DELETE, ATTRIB, MODIFY, and REVOKE
%\hline
%INOTIFY   & foo \\
%FEN       & foo \\
%KQUEUE    & foo \\
%KQUEUE1   & foo \\
%OPENAT    & foo \\
%FDOPENDIR & foo \\
%O\_CLOEXEC & foo \\
%IN\_CLOEXEC & foo \\
\end{tabular}

\subsubsection[\fn{notify.flags}]{\fn{notify.flags(bitset[, bitset $\ldots$ ])}}

Returns an iterator over the flags in the specified bitwise change sets. Thus, \texttt{notify.flags(bit32.xor(notify.CREATE, notify.DELETE), notify.MODIFY)} returns an iterator returning all three flags.

\subsubsection[\fn{notify.opendir}]{\fn{notify.opendir(path[, changes ])}}

Returns a notification object associated with the specified directory. Directory change events are limited to the set, `changes', or to notify.ALL if nil.

\subsubsection[\fn{notify:add}]{\fn{notify:add(name[, changes ])}}

Track the specified file name within the notification directory. `changes' defaults to notify.ALL if nil.

\subsubsection[\fn{notify:get}]{\fn{notify:get([timeout])}}

Returns a bitwise change set and a filename on success.

\subsubsection[\fn{notify:changes}]{\fn{notify:changes([timeout])}}

Returns an iterator over the \method{notify:get} method.

\end{Module}


\begin{Module}{cqueues.dns.record}

DNS resource record objects are implemented within \module{cqueues.dns.record}. The global tables and shared methods are documented below. The type-specific accessory methods are quite numerous. Until documented please confer with cqueues/src/dns.c. Also, the accessory method names are usually equivalent to the structure member names in cqueues/src/lib/dns.h, which in return usually reflect the member names in the relevant RFC.

The \fn{\_\_tostring} metamethod returns a representation of the record data only, excluding the name, type, ttl, etc. For an A record, it's equivalent to string.format(``\%s'', \fn{rr:addr()}). For MX---which has multiple members---it's string.format(``\%d \%s'', rr:preference(), rr:host()).

\subsubsection[\fn{record.type[]}]{\fn{record.type[]}}

A table mapping DNS record type string identifiers to number values, and vice-versa. So, \method{record.type.A} evaluates to 1, the IANA numeric record type. String identifiers are only provided for record types which are directly parseable and composable by the library. Currently supported types include A, NS, CNAME, SOA, PTR, MX, TXT, AAAA, SRV, OPT, SSHFP, and SPF. Other record types can be instantiated, but the numeric type must be used and the only methods available operate on the raw rdata.

\subsubsection[\fn{record.class[]}]{\fn{record.class[]}}

A table mapping DNS record class string identifiers to number values, and vice-versa. At present the only class included is IN.

\subsubsection[\fn{record.sshfp[]}]{\fn{record.sshfp[]}}

A table mapping DNS SSHFP record string identifiers to the number values---RSA, DSA, and SHA1.

\subsubsection[\fn{record:section}]{\fn{record:section()}}

Returns the section identifier from whence the record came, if derived from a packet. Specifically, QUESTION, ANSWER, AUTHORITY, or ADDITIONAL. See \module{cqueues.dns.packet.section[]}.

\subsubsection[\fn{record:name}]{\fn{record:name()}}

Returns the uncompressed record domain name as a string.

\subsubsection[\fn{record:type}]{\fn{record:type()}}

Returns the numeric record type. If `rr' holds an AAAA record, then the return value of rr:type() will compare equal to \module{record.type.AAAA}.

\subsubsection[\fn{record:class}]{\fn{record:class()}}

Returns the numeric record class. See \module{record.class[]}.

\subsubsection[\fn{record:ttl}]{\fn{record:ttl()}}

Returns the record TTL.

\end{Module}


\begin{Module}{cqueues.dns.packet}

DNS packets are stored in a simple structure encapsulating the raw packet data. One consequence is that packets are append only. Because a packet is composed of four adjacent sections, when building a packet all the information necessary should be at-hand so that records can be appended in order.

The \fn{\_\_tostring} metamethod composes a string similar to the output of the venerable dig utility.

\subsubsection[\fn{packet.section[]}]{\fn{packet.section[]}}

A table mapping packet section string identifiers to number values, and vice-versa. A packet is composed of only four sections: QUESTION, ANSWER, AUTHORITY, and ADDITIONAL.

\subsubsection[\fn{packet.opcode[]}]{\fn{packet.opcode[]}}

A table mapping packet opcode string identifiers to number values, and vice-versa. The currently mapped opcodes are QUERY, IQUERY, STATUS, NOTIFY, and UPDATE.

\subsubsection[\fn{packet.rcode[]}]{\fn{packet.rcode[]}}

A table mapping packet rcode string identifiers to number values, and vice-versa. The currently mapped rcodes are NOERROR, FORMERR, SERVFAIL, NXDOMAIN, NOTIMP, REFUSED, YXDOMAIN, YXRRSET, NXRRSET, NOTAUTH, and NOTZONE.

\subsubsection[\fn{packet.interpose}]{\fn{packet.interpose}}

Add or interpose a packet class method. Returns the previous method, if any.

\subsubsection[\fn{packet.new}]{\fn{packet.new([prepbufsiz])}}

Instantiate a new packet object. `prepbufsiz' is the maximum space available for appending compressed records. For constructing a packet with a single question, the most space possibly necessary is 260---256 bytes for the name, and 2 bytes each for the type and class (a QUESTION record has no TTL or rdata section).

\subsubsection[\fn{packet:qid}]{\fn{packet:qid()}}

Returns the 16-bit QID value.

\subsubsection[\fn{packet:flags}]{\fn{packet:flags()}}

Returns a table of packet header flags.

\begin{tabular}{ c | c | l }
field & type & description\\\hline
.qr & integer & specifies whether the packet is a query (0) or response (1)\\
.opcode & number & specifies the query type\\
.aa & boolean & signals an authoritative answer\\
.tc & boolean & signals packet truncation\\
.rd & boolean & signals ``recursion desired''\\
.ra & boolean & signals ``recursion available''\\
.z & boolean & reserved by RFC 1035 and used by other RFCs\\
.rcode & integer & specifies the response disposition
\end{tabular}

\subsubsection[\fn{packet:count}]{\fn{packet:count([sections])}}

Returns a count of records in the sections specified by the bitwise parameter `sections'. Defaults to \texttt{packet.section.ALL}, which is the XOR of all four sections.

\subsubsection[\fn{packet:grep}]{\fn{packet:grep\{ $\ldots$ \}}}

Returns a record iterator over the packet according to all the criteria specified by the optional table parameter.

\begin{tabular}{ c | l }
field & description\\\hline
.section & select records by bitwise AND with the specified sections\\
.type & select records of this type (not bitwise)\\
.class & selects records of this class (not bitwise)\\
.name & select records with this name
\end{tabular}

\end{Module}


\begin{Module}{cqueues.dns.config}

The traditional BSD /etc/resolv.conf file is the prototype for this module, although it's also capable of parsing /etc/nsswitch.conf. \module{cqueues.dns.config} objects are used when instantiating new resolver objects, and provide the general options controlling a resolver.

The \fn{\_\_tostring} metamethod composes a string adhering to /etc/resolv.conf syntax, with /etc/nsswitch.conf alternatives as comments.

\subsubsection[\fn{config[]}]{\fn{config[]}}

A table mapping flag identifiers to number values.

\begin{tabular}{ c | l }
field & description\\\hline
TCP\_ENABLE & fall back to TCP when truncation detected (default)\\
TCP\_ONLY & only use TCP when querying\\
TCP\_DISABLE & do not fall back to TCP\\
RESOLV\_CONF & specifies BSD /etc/resolv.conf input syntax\\
NSSWITCH\_CONF & specifies Solaris /etc/nsswitch.conf input syntax
\end{tabular}

\subsubsection[\fn{config.interpose}]{\fn{config.interpose(name, function)}}

Add or interpose a config class method. Returns the previous method, if any.

\subsubsection[\fn{config.new}]{\fn{config.new\{ $\ldots$ \}}}

Returns a new config object, optionally initialized according to the specified table values.

\begin{ctabular}{ c | c | p{5in} }
field & type & description\\\hline
.nameserver & table & list of IP address strings to use for stub resolvers\\
.search & table & list of domain suffixes to append to query names\\
.lookup & table & order of lookup methods---``file'' and ``bind''\\
.options & table & canonical location for .edns0, .ndots, .timeout, .attempts, .rotate, .recurse, .smart, and .tcp options\\
..edns0 & boolean & enable EDNS0 support\\
..ndots & number & if query name has fewer labels than this, reverse suffix search order\\
..timeout & number & timeout between query retries\\
..attempts & number & maximum number of attempts per nameserver\\
..rotate & boolean & randomize nameserver selection\\
..recurse & boolean & query recursively instead of as a simple stub resolver\\
..smart & boolean & for NS, MX, SRV and similar record queries, resolve the A record if not included as glue in the initial answer\\
..tcp & number & see TCP\_ENABLE, TCP\_ONLY, TCP\_DISABLE in \fn{config[]}\\
.interface & string & IP address to bind to when querying (e.g. [192.168.1.1]:1234)
\end{ctabular}
\subsubsection[\fn{config.stub}]{\fn{config.stub\{ $\ldots$ \}}}

Returns a config object initialized for a stub resolver by loading the relevant system files; e.g. /etc/resolv.conf and /etc/nsswitch.conf. Takes optional initialization values like \fn{config.new}.

\subsubsection[\fn{config.root}]{\fn{config.root\{ $\ldots$ \}}}

Returns a config object initialized for a recursive resolver. Takes optional initialization values like \fn{config.new}.

\subsubsection[\fn{config:loadfile}]{\fn{config:loadfile(file[, syntax])}}

Parse the Lua file object `file'. `syntax' describes the format, which should be RESOLV\_CONF (default), or NSSWITCH\_CONF.

\subsubsection[\fn{config:loadpath}]{\fn{config:loadpath(path[, syntax])}}

Like :loadfile, but takes a file path.

\subsubsection[\fn{config:get}]{\fn{config:get()}}

Returns the configuration as a Lua table structure. See \fn{config.new} for a description of the values.

\subsubsection[\fn{config:set}]{\fn{config:set\{ $\ldots$ \}}}

Apply the defined configuration values. The table should have the same structure as described for \fn{config.new}.

\end{Module}


\begin{Module}{cqueues.dns.hosts}

The traditional BSD /etc/hosts file is the prototype for this module, and provides resolvers the data source for the ``file'' lookup method.

The \fn{\_\_tostring} metamethod composes a string adhering to /etc/hosts syntax.

\subsubsection[\fn{hosts.interpose}]{\fn{hosts.interpose(name, function)}}

Add or interpose a hosts class method. Returns the previous method, if any.

\subsubsection[\fn{hosts.new}]{\fn{hosts.new()}}

Returns a new hosts object.

\subsubsection[\fn{hosts.stub}]{\fn{hosts.stub()}}

Returns a host object initialized for a stub resolver by loading the relevant system files; e.g. /etc/hosts.

\subsubsection[\fn{hosts.root}]{\fn{hosts.root()}}

Returns a hosts object initialized for a recursive resolver.

\subsubsection[\fn{hosts:loadfile}]{\fn{hosts:loadfile(file)}}

Parse the Lua file object `file' for host entries.

\subsubsection[\fn{hosts:loadpath}]{\fn{hosts:loadpath(path)}}

Like :loadfile, but takes a file path.

\subsubsection[\fn{hosts:insert}]{\fn{hosts:insert(address, name[, alias])}}

Inserts a new hosts entry. `address' should be an IPv4 or IPv6 address string, `name' the domain name, and `alias' a boolean---true if `name' is canonical and a valid response for a reverse address lookup.

\end{Module}


\begin{Module}{cqueues.dns.hints}

The internal DNS library is implemented as a recursive resolver. No matter whether configured as a stub or recursive resolver, when a query is submitted it consults a ``hints'' database for the initial name servers to contact. In stub mode these would usually be the local recursive, caching name servers, derived from the \module{cqueues.dns.config} object; in recursive mode, the root IANA name servers.

The \fn{\_\_tostring} metamethod composes a multi-line string indexing SOA zone names and addresses.

\subsubsection[\fn{hints.interpose}]{\fn{hints.interpose(name, function)}}

Add or interpose a hints class method. Returns the previous method, if any.

\subsubsection[\fn{hints.new}]{\fn{hints.new([resconf])}}

Returns a new hints object. `resconf' is an optional \module{cqueues.dns.config} object which in the future may be used to initialize database behavior. Currently it's unused, and \emph{does not} pre-load the name server list.

\subsubsection[\fn{hints.stub}]{\fn{hints.stub([resconf])}}

Returns a hints object initialized for a stub resolver. If provided, the initial hints are taken from the \module{cqueues.dns.config} object,  `resconf'. Otherwise, the hints are derived from a temporary ``stub'' config object internally.

\subsubsection[\fn{hints.root}]{\fn{hints.root([resconf])}}

Returns a hints object initialized for a recursive resolver. The root name servers are initialized from an internal database compiled into the module. See \fn{hints.new} for the function of the optional `resconf'.

\subsubsection[\fn{hints:insert}]{\fn{hints:insert(zone, address|resconf[, priority])}}

Inserts a new hints entry. `zone' is the domain name which anchors the SOA (e.g. ``.'', or ``com.''), and `address' the IPv4 or IPv6 of the nameserver. Alternatively, in lieu of a string address a \module{cqueues.dns.config} object can be specified, and the addresses taken from the nameserver list property. `priority' is used for ordering  nameservers in each zone.

IPv4 and IPv6 addresses can optionally contain a port component, e.g. ``[2001:503:ba3e::2:30]:123'' or ``[198.41.0.4]:53''.

\end{Module}


\begin{Module}{cqueues.dns.resolver}

\subsubsection[\fn{resolver.interpose}]{\fn{resolver.interpose(name, function)}}

Add or interpose a resolver class method. Returns the previous method, if any.

\subsubsection[\fn{resolver.new}]{\fn{resolver.new([resconf][,hosts][,hints])}}

Returns a new resolver object, configured according to the specified config, hosts, and hints objects. `resconf' can be either an object, or a table suitable for passing to \fn{config.new}. `hosts' and `hints', if nil, are instantiated according to the mode---recursive or stub---of the config object.

\subsubsection[\fn{resolver.stub}]{\fn{resolver.stub\{ $\ldots$ \}}}

Returns a stub resolver, optionally initialized to the defined config parameters, which should have a structure suitable for passing to \fn{cqueues.dns.config.new}.

\subsubsection[\fn{resolver.root}]{\fn{resolver.root\{ $\ldots$ \}}}

Returns a recursive resolver, optionally initialized to the defined config parameters, which should have a structure suitable for passing to \fn{cqueues.dns.config.new}.

\subsubsection[\fn{resolver:query}]{\fn{resolver:query(name[, type][, class][, timeout])}}

Query for the DNS resource record with the specified type and class. `name' is the fully-qualified or prefix domain name string. `type' and `class' are numbers corresponding to the IANA assigned numeric identifier, and default to A (0x01) and IN (0x01), respectively. `timeout' is the total elapsed time for resolution, irrespective of the .attempts and .timeout option values of the  configuration.

Returns a \module{cqueues.dns.packet} answer packet on success, or nil and a numeric error code on failure. The answer may not actually have anything in the ANSWERS section; e.g. if the RCODE is NXDOMAIN.

\subsubsection[\fn{resolver:stat}]{\fn{resolver:stat()}}

Returns a table of statistics for the resolver instance.

\begin{ctabular}{ c | p{5in}}
field & description\\\hline
.queries & number of queries submitted \\
.udp.sent.count & number of UDP packets sent \\
.udp.sent.bytes & number of UDP bytes sent \\
.udp.rcvd.count & number of UDP packets received \\
.udp.rcvd.bytes & number of UDP bytes received \\
.tcp.sent.count & number of TCP packets sent \\
.tcp.sent.bytes & number of TCP bytes sent \\
.tcp.rcvd.count & number of TCP packets received \\
.tcp.rcvd.bytes & number of TCP bytes received \\

\end{ctabular}
\subsubsection[\fn{resolver:close}]{\fn{resolver:close()}}

Explicitly destroy the resolver object, immediately closing all internal descriptors. This routine ensures all descriptors are properly cancelled.

\end{Module}


\begin{Module}{openssl.bignum}

\module{openssl.bignum} binds OpenSSL's libcrypto bignum library. It supports all the standard arithmetic operations. Regular number operands in a mixed arithmetic expression are upgraded as-if \method{bignum.new} was used explicitly. The \fn{to string} metamethod generates a decimal encoded represention.

\subsubsection[\fn{bignum.new}]{\fn{bignum.new(number)}}

Wraps the sign and integral part of `number' as a bignum object, discarding any fractional part.

\subsubsection[\fn{bignum.interpose}]{\fn{bignum.interpose(name, function)}}

Add or interpose a bignum class method. Returns the previous method, if any.

\end{Module}


\begin{Module}{openssl.pubkey}

\module{openssl.pubkey} binds OpenSSL's libcrypto public-private key library. The \fn{tostring} metamethod generates a PEM encoded representation of the public key---excluding the private key.

\subsubsection[\fn{pubkey.new}]{\fn{pubkey.new(string)}}

Initializes a new pubkey object from the PEM-encoded key in `string'.

\subsubsection[\fn{pubkey.new}]{\fn{pubkey.new\{ $\ldots$ \}}}

Generates a new pubkey object according to the specified parameters.

\begin{ctabular}{ c | c | p{5in}}
field & type:default & description\\\hline
.type & string:RSA & public key algorithm---``RSA'', ``DSA'', ``EC'', ``DH'', or an internal OpenSSL identifier of a subclass of one of those basic types \\

.bits & number:1024 & private key size \\

.exp & number:65537 & RSA or Diffie-Hellman exponent \\

.curve & string:prime192v1 & for elliptic curve keys, the OpenSSL string identifier of the curve
\end{ctabular}
\subsubsection[\fn{pubkey.interpose}]{\fn{pubkey.interpose(name, function)}}

Add or interpose a pubkey class method. Returns the previous method, if any.

\subsubsection[\fn{pubkey:type}]{\fn{pubkey:type()}}

Returns the OpenSSL string identifier for the type of key.

\subsubsection[\fn{pubkey:setPublicKey}]{\fn{pubkey:setPublicKey(string)}}

Set the public key component to that described by the PEM encoded public key in `string'.

\subsubsection[\fn{pubkey:setPrivateKey}]{\fn{pubkey:setPrivateKey(string)}}

Set the private key component to that described by the PEM encoded private key in `string'.

\subsubsection[\fn{pubkey:sign}]{\fn{pubkey:sign(digest)}}

Sign data which has been consumed by the specified \module{openssl.digest} `digest'. Digests and keys are not all interchangeable. For example, an elliptic curve key requires a digest of type ``ecdsa-with-SHA1'', while DSA requires ``dss1''. OpenSSL supports more varied digests for RSA.

Returns the signature as an opaque binary string\footnote{Elliptic curve signatures are two X.509 DER-encoded numbers, for example, while RSA signatures are encrypted DER structures.} on success, and throws an error otherwise.

\subsubsection[\fn{pubkey:verify}]{\fn{pubkey:verify(signature, digest)}}

Verify the string `signature' as signing the document consumed by \module{openssl.digest} `digest`. See the :sign method for constraints on the format and type of the parameters.

Returns true on success, false for properly formatted but invalid signatures, and throws an error otherwise. Because the structure of the signature is opaque and not susceptible to sanity checking before passing to OpenSSL, an application should always be prepared for an error to be thrown when verifying untrusted signatures. OpenSSL, of course, should be able to handle all malformed inputs. But the module does not attempt to differentiate local system errors from errors triggered by malformed signatures because the set of such errors may change in the future.

\subsubsection[\fn{pubkey:toPEM}]{\fn{pubkey:toPEM(which[, which])}}

Returns the PEM encoded string representation(s) of the specified key component. `which' must be one of ``public'', ``PublicKey'', ``private'', or ``PrivateKey''. For the two argument form, returns two values.

\end{Module}


\begin{Module}{openssl.x509.name}

Binds the X.509 distinguished name OpenSSL ASN.1 object, used for representing certificate subject and issuer names.

\subsubsection[\fn{name.new}]{\fn{name.new()}}

Returns an empty name object.

\subsubsection[\fn{name.interpose}]{\fn{name.interpose(name, function)}}

Add or interpose a name class method. Returns the previous method, if any.

\subsubsection[\fn{name:add}]{\fn{name:add(type, value)}}

Add a distinguished name component. `type' is the OpenSSL string identifier of the component type---short, long, or OID forms. `value' is the string value of the component. DN components are free-form, and are encoded raw.

\subsubsection[\fn{name:all}]{\fn{name:all()}}

Returns a table array of the distinguished name components. Each element is a table with four fields:

\begin{tabular}{ l | l}
field & description\\\hline
.sn & short name identifier, if available\\
.ln & long name identifier, if available\\
.id & OID identifier\\
.blob & raw string value of the component
\end{tabular}

\subsubsection[\fn{name:\_\_pairs}]{\fn{name:\_\_pairs()}}

Returns a key-value iterator over the distinguished name components. The key is either the short, long, or OID identifier, with preference for the former.

\end{Module}


\begin{Module}{openssl.x509.altname}

Binds the X.509 alternative names (a.k.a ``general names'') OpenSSL ASN.1 object, used for representing certificate subject and issuer alternative names.

\subsubsection[\fn{altname.new}]{\fn{altname.new()}}

Returns an empty altname object.

\subsubsection[\fn{altname.interpose}]{\fn{altname.interpose(name, function)}}

Add or interpose an altname class method. Returns the previous method, if any.

\subsubsection[\fn{altname:add}]{\fn{altname:add(type, value)}}

Add an alternative name. `type' must specify one of the four basic types identified by ``RFC822Name'', ``RFC822'', ``email'', ``UniformResourceIdentifier'', ``URI'', ``DNSName'', ``DNS'', ``IPAddress'', and ``IP''.

`value' is a string acceptable to OpenSSL's sanity checks. For an IP address, `value' must be parseable by the system's \fn{inet\_pton} routine, as IP addresses are stored as raw 4- or 16-byte octets.

\subsubsection[\fn{name:\_\_pairs}]{\fn{name:\_\_pairs()}}

Returns a key-value iterator over the alternative names. The key is one of ``email'', ``URI'', ``DNS'', or ``IP''. The value is the string representation of the name.

\end{Module}


\begin{Module}{openssl.x509}

Binds the X.509 certificate OpenSSL ASN.1 object.

\subsubsection[\fn{x509.new}]{\fn{x509.new([string])}}

Returns a new x509 object, optionally initialized to the PEM encoded certificate specified by `string'.

\subsubsection[\fn{x509.interpose}]{\fn{x509.interpose(name, function)}}

Add or interpose an x509 class method. Returns the previous method, if any.

\subsubsection[\fn{x509:getVersion}]{\fn{x509:getVersion()}}

Returns the X.509 version of the certificate.

\subsubsection[\fn{x509:setVersion}]{\fn{x509:setVersion(number)}}

Sets the X.509 version of the certificate.

\subsubsection[\fn{x509:getSerial}]{\fn{x509:getSerial()}}

Returns the serial of the certificate as an \module{openssl.bignum}.

\subsubsection[\fn{x509:setSerial}]{\fn{x509:setSerial(number)}}

Sets the serial of the certificate. `number' is a Lua or \module{openssl.bignum} number.

\subsubsection[\fn{x509:digest}]{\fn{x509:digest([type[, format]])}}

Returns the cryptographic one-way message digest of the certificate. `type' is the OpenSSL string identifier of the hash type---e.g. ``md5'', ``sha1'' (default), ``sha256'', etc. `format' specifies the representation of the digest---``s'' for an octet string, ``x'' for a hexadecimal string (default), and ``n'' for an \module{openssl.bignum} number.

\subsubsection[\fn{x509:getLifetime}]{\fn{x509:getLifetime()}}

Returns the certificate validity ``Not Before'' and ``Not After'' dates as two Unix timestamp numbers.

\subsubsection[\fn{x509:setLifetime}]{\fn{x509:setLifetime([notbefore][, notafter])}}

Sets the certificate validity dates. A nil value leaves the particular date unchanged.

\subsubsection[\fn{x509:getIssuer}]{\fn{x509:getIssuer()}}

Returns the issuer distinguished name as an \module{x509.name} object.

\subsubsection[\fn{x509:setIssuer}]{\fn{x509:setIssuer(name)}}

Sets the issuer distinguished name.

\subsubsection[\fn{x509:getSubject}]{\fn{x509:getSubject()}}

Returns the subject distinguished name as an \module{x509.name} object.

\subsubsection[\fn{x509:setSubject}]{\fn{x509:setSubject(name)}}

Sets the subject distinguished name.

\subsubsection[\fn{x509:getIssuerAlt}]{\fn{x509:getIssuerAlt()}}

Returns the issuer alternative names as an \module{x509.altname} object.

\subsubsection[\fn{x509:setIssuerAlt}]{\fn{x509:setIssuer(altname)}}

Sets the issuer alternative names.

\subsubsection[\fn{x509:getSubjectAlt}]{\fn{x509:getSubjectAlt()}}

Returns the subject alternative names as an \module{x509.name} object.

\subsubsection[\fn{x509:setSubjectAlt}]{\fn{x509:setSubjectAlt(name)}}

Sets the subject alternative names.

\subsubsection[\fn{x509:getIssuerAltCritical}]{\fn{x509:getIssuerAltCritical()}}

Returns the issuer alternative names critical flag as a boolean.

\subsubsection[\fn{x509:setIssuerAltCritical}]{\fn{x509:setIssuerAltCritical(boolean)}}

Sets the issuer alternative names critical flag.

\subsubsection[\fn{x509:getSubjectAltCritical}]{\fn{x509:getSubjectAltCritical()}}

Returns the subject alternative names critical flag as a boolean.

\subsubsection[\fn{x509:setSubjectAltCritical}]{\fn{x509:setSubjectAltCritical(boolean)}}

Sets the subject alternative names critical flag.

\subsubsection[\fn{x509:getBasicConstraints}]{\fn{x509:getBasicConstraints([which[, which $\ldots$ ]])}}

Returns the X.509 ``basic constraint'' flags. If specified, `which' should be one of ``CA'' or ``pathLen'', which returns the specified constraint---respectively, a boolean and a number.  If no parameters are specified, returns a table with fields ``CA'' and ``pathLen''.

\subsubsection[\fn{x509:setBasicConstraints}]{\fn{x509:setBasicConstraints\{ $\ldots$ \}}}

Sets the basic constraint flag according to the defined field values for ``CA'' (boolean) and ``pathLen'' (number).

\subsubsection[\fn{x509:getBasicConstraintsCritical}]{\fn{x509:getBasicConstraintsCritical()}}

Returns the basic constraints critical flag as a boolean.

\subsubsection[\fn{x509:setBasicConstraintsCritical}]{\fn{x509:setBasicConstraintsCritical(boolean)}}

Sets the basic constraints critical flag.

\subsubsection[\fn{x509:isIssuedBy}]{\fn{x509:isIssuedBy(issuer)}}

Returns a boolean according to whether the specified issuer---an \module{openssl.x509} object---signed the instance certificate.

\subsubsection[\fn{x509:getPublicKey}]{\fn{x509:getPublicKey()}}

Returns the public key component as an \module{openssl.pubkey} object.

\subsubsection[\fn{x509:setPublicKey}]{\fn{x509:setPublicKey(key)}}

Sets the public key component referenced by the \module{openssl.pubkey} object `key'.

\subsubsection[\fn{x509:sign}]{\fn{x509:sign(key)}}

Signs the instance certificate using the \module{openssl.pubkey} `key'.

\subsubsection[\fn{x509:\_\_tostring}]{\fn{x509:\_\_tostring}}

Returns the PEM encoded representation of the instance certificate.

\end{Module}


\begin{Module}{openssl.x509.csr}

Binds the X.509 certificate signing request OpenSSL ASN.1 object.

\subsubsection[\fn{csr.new}]{\fn{csr.new([x509|string])}}

Returns a new request object, optionally initialized to the specified \module{openssl.x509} certificate `x509' or the the PEM encoded certificate signing request `string'.

\subsubsection[\fn{csr.interpose}]{\fn{csr.interpose(name, function)}}

Add or interpose a request class method. Returns the previous method, if any.

\subsubsection[\fn{csr:getVersion}]{\fn{csr:getVersion()}}

Returns the X.509 version of the request.

\subsubsection[\fn{car:setVersion}]{\fn{csr:setVersion(number)}}

Sets the X.509 version of the request.

\subsubsection[\fn{csr:getSubject}]{\fn{csr:getSubject()}}

Returns the subject distinguished name as an \module{x509.name} object.

\subsubsection[\fn{csr:setSubject}]{\fn{csr:setSubject(name)}}

Sets the subject distinguished name.

\subsubsection[\fn{csr:getPublicKey}]{\fn{csr:getPublicKey()}}

Returns the public key component as an \module{openssl.pubkey} object.

\subsubsection[\fn{csr:setPublicKey}]{\fn{csr:setPublicKey(key)}}

Sets the public key component referenced by the \module{openssl.pubkey} object `key'.

\subsubsection[\fn{car:sign}]{\fn{csr:sign(key)}}

Signs the instance request using the \module{openssl.pubkey} `key'.

\subsubsection[\fn{csr:\_\_tostring}]{\fn{csr:\_\_tostring}}

Returns the PEM encoded representation of the instance request.

\end{Module}


\begin{Module}{openssl.x509.chain}

Binds the ``STACK\_OF(X509)'' OpenSSL object, principally used in the OpenSSL library for representing a validation chain.

\subsubsection[\fn{chain.new}]{\fn{chain.new()}}

Returns a new chain object.

\subsubsection[\fn{chain.interpose}]{\fn{chain.interpose(name, function)}}

Add or interpose a chain class method. Returns the previous method, if any.

\subsubsection[\fn{chain:add}]{\fn{chain:add(x509)}}

Append the X.509 certificate `x509'.

\subsubsection[\fn{chain:\_\_ipairs}]{\fn{chain:\_\_ipairs()}}

Returns an iterator over the stored certificates.

\end{Module}


\begin{Module}{openssl.x509.store}

Binds the X.509 certificate ``X509\_STORE'' OpenSSL object, principally used for loading and storing trusted certificates, paths to trusted certificates, and verification policy.

\subsubsection[\fn{store.new}]{\fn{store.new()}}

Returns a new store object.

\subsubsection[\fn{store.interpose}]{\fn{store.interpose(name, function)}}

Add or interpose a store class method. Returns the previous method, if any.

\subsubsection[\fn{store:add}]{\fn{store:add(x509|filepath|dirpath)}}

Add the X.509 certificate `x509' to the store, load the certificates from the file `filepath', or set the OpenSSL ``hash dir'' certificate path `dirpath'.

\subsubsection[\fn{store:verify}]{\fn{store:verify(x509[, chain])}}

Returns two values. The first is a boolean value for whether the specified certificate `x509' was verified. If true, the second value is a  \module{openssl.x509.chain} object validation chain. If false, the second value is a string describing why verification failed. The optional parameter `chain' is an \module{openssl.x509.chain} object of untrusted certificates linking the certificate `x509' to one of the trusted certificates in the instance store.

\end{Module}


\begin{Module}{openssl.ssl.context}

Binds the ``SSL\_CTX'' OpenSSL object, used as a configuration prototype for SSL connection instances. See \method{socket.starttls}.

\subsubsection[\fn{context[]}]{\fn{context[]}}

A table mapping bitwise flags to names.

\begin{tabular}{ c | l }
name & description \\\hline
VERIFY\_NONE & disable client peer certificate verification \\
VERIFY\_PEER & enable client peer certificate verification \\
VERIFY\_FAIL\_IF\_NO\_PEER\_CERT & require a peer certificate \\
VERIFY\_CLIENT\_ONCE & do not request peer certificates after initial handshake
\end{tabular}

See the \href{http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html#NOTES}{NOTES section} in the OpenSSL documentation for \fn{SSL\_CTX\_set\_verify\_mode}.

\subsubsection[\fn{context.new}]{\fn{context.new([protocol][, server])}}

Returns a new context object. `protocol' is an optional string identifier selecting the SSL mode---TLSv1 (default), SSLv3, SSLv23, or SSLv2. If `server' is true, then SSL connections instantiated using this context will be placed into server mode, otherwise they behave as clients.

\subsubsection[\fn{context.interpose}]{\fn{context.interpose(name, function)}}

Add or interpose a context class method. Returns the previous method, if any.

\subsubsection[\fn{context:setStore}]{\fn{context:setStore(store)}}

Sets the \module{x509.store} of the context instance.

\subsubsection[\fn{context:getVerify}]{\fn{context:getVerify()}}

Returns two values: the bitwise verification mode flags, and the maximum validation depth.

\subsubsection[\fn{context:setVerify}]{\fn{context:setVerify([mode][, depth])}}

Sets the verification mode flags and maximum validation chain depth.

\subsubsection[\fn{context:setCertificate}]{\fn{context:setCertificate(x509)}}

Sets the X.509 certificate \module{openssl.x509} object `x509' to send during SSL connection instance handshakes.

\subsubsection[\fn{context:setPrivateKey}]{\fn{context:setPrivateKey(key)}}

Sets the private key \module{openssl.pubkey} object `key' for use during SSL connection instance handshakes.

\subsubsection[\fn{context:setCipherList}]{\fn{context:setCipherList(string)}}

Sets the allowed public key and private key algorithms. The string format is documented in the \href{http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT}{OpenSSL ciphers(1) utility documentation}.

\end{Module}


\begin{Module}{openssl.ssl}

Binds the ``SSL'' OpenSSL object, which represents an SSL connection instance. See \method{socket.checktls}.

\subsubsection[\fn{ssl.interpose}]{\fn{ssl.interpose(name, function)}}

Add or interpose an ssl class method. Returns the previous method, if any.

\subsubsection[\fn{ssl:getPeerCertificate}]{\fn{ssl:getPeerCertificate()}}

Returns the X.509 peer certificate as a \module{cqueues.openssl.x509} object. If no peer certificate is available, returns nil.

\subsubsection[\fn{ssl:getPeerChain}]{\fn{ssl:getPeerChain()}}

Similar to :getPeerCertifiate, but returns the entire chain sent by the peer as a \module{cqueues.openssl.x509.chain} object.

\subsubsection[\fn{ssl:getCipherInfo}]{\fn{ssl:getCipherInfo()}}

Returns a table of information on the current cipher. 

\begin{tabular}{ c | l }
field & description\\\hline
.name & cipher name returned by \fn{SSL\_CIPHER\_get\_name}\\
.bits & number of secret bits returned by \fn{SSL\_CIPHER\_get\_bits}\\
.version & SSL/TLS version string returned by \fn{SSL\_CIPHER\_get\_version}\\
.description & key:value cipher description returned by \fn{SSL\_CIPHER\_description}
\end{tabular}

\end{Module}


\begin{Module}{openssl.digest}

Binds the ``EVP\_MD\_CTX'' OpenSSL object, which represents a cryptographic message digest (i.e. hashing) algorithm instance.

\subsubsection[\fn{digest.interpose}]{\fn{digest.interpose(name, function)}}

Add or interpose a digest class method. Returns the previous method, if any.

\subsubsection[\fn{digest.new}]{\fn{digest.new([type])}}

Return a new digest instance using the specified algorithm `type'. `type' is a string suitable for passing to the OpenSSL routine EVP\_get\_digestbyname, and defaults to ``sha1''.

\subsubsection[\fn{digest:update}]{\fn{digest:update([string [, ...]])}}

Update the digest with the specified strings. Returns true.

\subsubsection[\fn{digest:final}]{\fn{digest:final([string [, ...]])}}

Update the digest with the specified strings. Returns the final message digest as a binary string.

\end{Module}


\begin{Module}{openssl.hmac}

Binds the ``HMAC\_CTX'' OpenSSL object, which represents a cryptographic HMAC algorithm instance.

\subsubsection[\fn{hmac.interpose}]{\fn{hmac.interpose(name, function)}}

Add or interpose an HMAC class method. Returns the previous method, if any.

\subsubsection[\fn{hmac.new}]{\fn{hmac.new(key [, type])}}

Return a new HMAC instance using the specified `key' and `type'. `key' is the secret used for HMAC authentication. `type' is a string suitable for passing to the OpenSSL routine EVP\_get\_digestbyname, and defaults to ``sha1''.

\subsubsection[\fn{hmac:update}]{\fn{hmac:update([string [, ...]])}}

Update the HMAC with the specified strings. Returns true.

\subsubsection[\fn{hmac:final}]{\fn{hmac:final([string [, ...]])}}

Update the HMAC with the specified strings. Returns the final HMAC checksum as a binary string.

\end{Module}


\begin{Module}{openssl.cipher}

Binds the ``EVP\_CIPHER\_CTX'' OpenSSL object, which represents a cryptographic cipher instance.

\subsubsection[\fn{cipher.interpose}]{\fn{cipher.interpose(name, function)}}

Add or interpose a cipher class method. Returns the previous method, if any.

\subsubsection[\fn{cipher.new}]{\fn{cipher.new(type)}}

Return a new, uninitialized cipher instance. `type' is a string suitable for passing to the OpenSSL routine EVP\_get\_cipherbyname, typically of a form similar to ``AES-128-CBC''.

The cipher is uninitialized because some algorithms support or require additional \textit{ad hoc} parameters before key initialization. The API still allows one-shot encryption like ``cipher.new(type):encrypt(key, iv):final(plaintext)''.

\subsubsection[\fn{cipher:encrypt}]{\fn{cipher:encrypt(key [, iv] [, padding])}}

Initialize the cipher in encryption mode. `key' and `iv' are binary strings with lengths equal to that required by the cipher instance as configured. In other words, key stretching and other transformations must be done explicitly. If the mode does not take an IV or equivalent, such as in ECB mode, then it may be nil. `padding' is a boolean which controls whether PKCS padding is applied, and defaults to true. Returns the cipher instance.

\subsubsection[\fn{cipher:decrypt}]{\fn{cipher:decrypt(key [, iv] [, padding])}}

Initialize the cipher in decryption mode. `key', `iv', and `padding' are as described in :encrypt. Returns the cipher instance.

\subsubsection[\fn{cipher:update}]{\fn{cipher:update([string [, ...]])}}

Update the cipher instance with the specified strings. Returns a string on success, or nil and an error message on failure. The returned string may be empty if no blocks can be flushed.

\subsubsection[\fn{cipher:final}]{\fn{cipher:final([string [, ...]])}}

Update the cipher with the specified strings. Returns the final output string on success, or nil and an error message on failure. The returned string may be empty if all blocks have already been flushed in prior :update calls.

\end{Module}


\chapter{Examples}

\section{HTTP SSL Request}

\begin{example}{lua}
local cqueues = require"cqueues"
local socket = require"cqueues.socket"

local http = socket.connect("google.com", 443)

http:starttls()

local cq = cqueues.new()

cq:wrap(function()
	http:write("GET / HTTP/1.0\n")
	http:write("Host: google.com:443\n\n")

	local status = http:read()
	print("!", status)

	for ln in http:lines"*h" do
		print("|", ln)
	end

	local empty = http:read"*L"
	print"~"

	for ln in http:lines"*L" do
		io.stdout:write(ln)
	end

	http:close()
end)

while not cq:empty() do
	local ok, why = cq:step()

	if not ok then
		error("cqueue: " .. why)
	end
end
\end{example}


\clearpage
\section{Multiplexing Echo Server}

\begin{example}{lua}
local cqueues = require"cqueues"
local socket = require"cqueues.socket"
local bind, port, wait = ...

local srv = socket.listen(bind or "127.0.0.1", tonumber(port or 8000))

local cq = cqueues.new()

cq:wrap(function()
	for con in srv:clients(wait) do
		cq:wrap(function()
			for ln in con:lines("*L") do
				cq:write(ln)
			end

			cq:shutdown("w")
		end)
	end
end)

while not cq:empty() do
	local ok, err = cq:step()
	if not ok then error("step: " .. err) end
end
\end{example}

\clearpage
\section{Thread Messaging}

\begin{example}{lua}
local cqueues = require"cqueues"
local thread = require"cqueues.thread"

-- we start a thread and pass two parameters--`0' and '9'
local thr, con = thread.start(function(con, i, j)
	-- the `cqueues' upvalue defined above is gone
	local cqueues = require"cqueues"
	local cq = cqueues.new()

	cq:wrap(function()
		for n = tonumber(i), tonumber(j) do
			io.stdout:write("sent ", n, "\n")
			con:write(n, "\n")
			 -- sleep so our stdout writes don't mix
			cqueues.sleep(0.1)
		end
	end)

	while not cq:empty() do
		local ok, why = cq:step()
		if not ok then error(why) end
	end
end, 0, 9)


local cq = cqueues.new()

cq:wrap(function()
	for ln in con:lines() do
		io.stdout:write(ln, " rcvd", "\n")
	end

	local ok, why = thr:join()

	if ok then
		print(why or "OK")
	else
		error(require"cqueues.errno".strerror(why))
	end
end)

while not cq:empty() do
	local ok, err = cq:step()
	if err then print(err) end
end
\end{example}



\appendix
\printindex

\end{document}
